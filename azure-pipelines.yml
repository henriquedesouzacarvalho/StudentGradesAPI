# Azure DevOps Pipeline for StudentGradesAPI .NET 9 Application
trigger:
  branches:
    include:
      - main
      - develop
      - feature/*
      - fix/*
  paths:
    exclude:
      - README.md
      - docs/*

pr:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - README.md
      - docs/*

variables:
  - group: semantic-release-secrets
  - name: buildConfiguration
    value: "Release"
  - name: dotNetVersion
    value: "9.x"
  - name: projectPath
    value: "API/StudentGradesAPI.csproj"
  - name: testProjectPath
    value: "StudentGradesAPI.Tests/StudentGradesAPI.Tests.csproj"
  - name: solutionPath
    value: "StudentGradesAPI.sln"

stages:
  - stage: Build
    displayName: "Build and Test"
    jobs:
      - job: BuildAndTest
        displayName: "Build and Test Application"
        pool:
          vmImage: "ubuntu-latest"

        steps:
          - checkout: self
            fetchDepth: "0"
            persistCredentials: "true"

          - task: NodeTool@0
            inputs:
              versionSpec: "18.x"

          - task: PowerShell@2
            displayName: "Semantic Release"
            inputs:
              targetType: "inline"
              script: |
                npm ci

                # Configurar git
                git config user.email "pipeline@company.com"
                git config user.name "Azure Pipeline"

                # Executar semantic-release
                $env:GITHUB_TOKEN = "$(GITHUB_TOKEN)"
                $output = npx semantic-release 2>&1 | Out-String
                Write-Host $output

                # Capturar vers찾o
                $packageJson = Get-Content package.json | ConvertFrom-Json
                $version = $packageJson.version
                Write-Host "##vso[task.setvariable variable=NextVersion]$version"
                Write-Host "##vso[build.updatebuildnumber]$version"
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)

          # - task: PowerShell@2
          #   displayName: "Semantic Release"
          #   inputs:
          #     targetType: "inline"
          #     script: |
          #       npm ci

          #       Write-Host "=== Executando semantic-release ==="
          #       $env:GITHUB_TOKEN = "$(System.AccessToken)"

          #       $output = npx semantic-release 2>&1 | Out-String
          #       Write-Host $output

          #       # Captura vers찾o de qualquer tipo de release
          #       if ($output -match "Published release ([0-9]+\.[0-9]+\.[0-9]+(?:-[a-zA-Z0-9\.\-]+)?)") {
          #         $version = $matches[1]
          #         Write-Host "Version created: $version"
          #       } else {
          #         # Fallback para package.json
          #         $packageJson = Get-Content package.json | ConvertFrom-Json
          #         $version = $packageJson.version
          #         Write-Host "Version fallback: $version"
          #       }

          #       Write-Host "##vso[task.setvariable variable=NextVersion]$version"
          #       Write-Host "##vso[build.updatebuildnumber]$version"

          # - task: PowerShell@2
          #   displayName: "Set Build Number"
          #   inputs:
          #     targetType: "inline"
          #     script: |
          #       Write-Host "Setting build number to: $(NextVersion)"
          #       Write-Host "##vso[build.updatebuildnumber]$(NextVersion)"

          # - task: PowerShell@2
          #   displayName: "Create Git Tag"
          #   condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
          #   inputs:
          #     targetType: "inline"
          #     script: |
          #       # Configurar Git
          #       git config user.email "pipeline@company.com"
          #       git config user.name "Azure Pipeline"

          #       # S처 criar tag se semantic-release n찾o criou (dry-run)
          #       if ("$(Build.SourceBranch)" -ne "refs/heads/main") {
          #         Write-Host "Creating tag for non-main branch: v$(NextVersion)"
          #         git tag "v$(NextVersion)"
          #         git push origin "v$(NextVersion)"
          #       } else {
          #         Write-Host "Tag already created by semantic-release"
          #       }

          - task: UseDotNet@2
            displayName: "Install .NET 9 SDK"
            inputs:
              packageType: "sdk"
              version: "$(dotNetVersion)"
              includePreviewVersions: false

          - task: DotNetCoreCLI@2
            displayName: "Restore packages"
            inputs:
              command: "restore"
              projects: "$(solutionPath)"

          - task: DotNetCoreCLI@2
            displayName: "Build solution"
            inputs:
              command: "build"
              projects: "$(solutionPath)"
              arguments: "--configuration $(buildConfiguration) --no-restore /p:Version=$(NextVersion)"

          - task: DotNetCoreCLI@2
            displayName: "Run tests"
            inputs:
              command: "test"
              projects: "$(testProjectPath)"
              arguments: '--configuration $(buildConfiguration) --no-build --logger trx --collect:"XPlat Code Coverage" --settings coverlet.runsettings'
              publishTestResults: true

          - task: PublishTestResults@2
            displayName: "Publish test results"
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "**/*.trx"
              mergeTestResults: true

          - task: DotNetCoreCLI@2
            displayName: "Publish application"
            inputs:
              command: "publish"
              projects: "$(projectPath)"
              arguments: "--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory) --no-build"
              zipAfterPublish: true

          - publish: "$(Build.ArtifactStagingDirectory)"
            artifact: "drop"
            displayName: "Publish artifacts"

  - stage: DeployDev
    displayName: "Deploy to Development"
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployToDev
        displayName: "Deploy to Development Environment"
        pool:
          vmImage: "ubuntu-latest"
        environment: "Development"
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: "drop"

                - task: AzureWebApp@1
                  displayName: "Deploy to Azure App Service"
                  inputs:
                    azureSubscription: "Azure-StudentGrades-Connection"
                    appType: "webApp"
                    appName: "studentgrades-dev"
                    package: "$(Pipeline.Workspace)/drop/*.zip"

  - stage: DeployProd
    displayName: "Deploy to Production"
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployToProd
        displayName: "Deploy to Production Environment"
        pool:
          vmImage: "ubuntu-latest"
        environment: "Production"
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: "drop"

                - task: AzureWebApp@1
                  displayName: "Deploy to Azure App Service"
                  inputs:
                    azureSubscription: "Azure-StudentGrades-Connection"
                    appType: "webApp"
                    appName: "studentgrades-prod"
                    package: "$(Pipeline.Workspace)/drop/*.zip"
